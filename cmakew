#!/bin/sh

# https://github.com/leleliu008/cmakew



_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}" >&2
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

die() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit 1
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        '') return 1 ;;
        */*)
            case $(uname | tr A-Z a-z) in
                cygwin*)
                    case $1 in
                        /cygdrive/*/choco) executable "$1" ;;
                        /cygdrive/*) return 1 ;;
                        *) executable "$1" ;;
                    esac
                    ;;
                *) executable "$1" ;;
            esac
            ;;
        *)  command_exists_in_filesystem $(command -v "$1" || true)
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    printf '%s\n'
    printf '%b\n' "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

step2() {
    STEP2_NUM=$(expr ${STEP2_NUM-0} + 1)
    STEP2_MESSAGE="$@"
    printf '%s\n'
    printf '%b\n' "${COLOR_BLUE}>>> STEP ${STEP_NUM}.${STEP2_NUM} : ${STEP2_MESSAGE} ${COLOR_OFF}"
}

run() {
    if [ "$RUN_SILENT" != yes ] ; then
        echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    fi

    eval "$*"
}

list() {
    for item in $@
    do
        printf '%s\n' "$item"
    done
}

list_length() {
    printf '%s\n' $#
}

shiftn() {
    shift "$1" && shift && printf '%s\n' "$@"
}

globing() {
    case $1 in
        '')   ;;
        \~/*) printf '%s\n' "$HOME/$(printf '%s\n' "$1" | cut -c3-)" ;;
        *)    printf '%s\n' "$1"
    esac
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        error "please install sed utility."
        return 1
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        printf '%s\n' "$1" | cut -d= -f2
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            printf '%s\n' "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            error "please install GNU CoreUtils or awk."
            return 1
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            printf '%s\n' "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            printf '%s\n' "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            printf '%s\n' "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            error "please install GNU CoreUtils or awk."
            return 1
        fi
    fi
}

own() {
    if command -v awk > /dev/null ; then
        ls -ld "$1" | awk '{print $3":"$4}'
    else
        ls -ld "$1" | cut -d ' ' -f4,6 | tr ' ' ':'
    fi
}

is_integer () {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

is_elf_file() {
    [ -z "$1" ] && {
        error "is_elf_file <FILE-PATH>, <FILE-PATH> is not given."
        return 1
    }

    if command -v hexdump > /dev/null ; then
        [ "$(hexdump -n 4 -v -e '1/1 "%02X" ""' "$1")" = '7F454C46' ]
    else
        error "hexdump command is needed, please install it."
        return 1
    fi
}

# format_unix_timestamp <TIMESTAMP-UNIX> <TO-FORMAT> [-u]
  format_unix_timestamp() {
   date $3 -jf "%s" "$1" "$2" 2> /dev/null ||
   date $3 -d      "@$1" "$2"
}

# https://equa.space/sh/lolcat/
lolcat_awk() {
    awk -v angle=45 -v angle_phase=40 -v reverse=0 -v offset=195 -v offset_phase=0 -v width=100 -v width_phase=8 "$@" '
    function put_rgb(color) {
        printf "\033[%s38;2;%d;%d;%dm", reverse ? "7;" : "", int(color[1] * 255), int(color[2] * 255), int(color[3] * 255);
    }

    function hsv_to_rgb(hsv, rgb, c, h2, x) {
        c = hsv[2] * hsv[3];
        h2 = hsv[1] * 6;
        x = c * (1 - ((h2 % 2) - 1 > 0 ? (h2 % 2) - 1 : 1 - (h2 % 2)));
        if (int(h2) % 6 == 0) {
            rgb[1] = c; rgb[2] = x; rgb[3] = 0;
        } else if (int(h2) % 6 == 1) {
            rgb[1] = x; rgb[2] = c; rgb[3] = 0;
        } else if (int(h2) % 6 == 2) {
            rgb[1] = 0; rgb[2] = c; rgb[3] = x;
        } else if (int(h2) % 6 == 3) {
            rgb[1] = 0; rgb[2] = x; rgb[3] = c;
        } else if (int(h2) % 6 == 4) {
            rgb[1] = x; rgb[2] = 0; rgb[3] = c;
        } else if (int(h2) % 6 == 5) {
            rgb[1] = c; rgb[2] = 0; rgb[3] = x;
        }

        rgb[1] += hsv[2] - c;
        rgb[2] += hsv[2] - c;
        rgb[3] += hsv[2] - c;
    }

    BEGIN {
        srand();
        if (offset == "") offset = rand() * 360;
    }

    {
        y = NR - 1;
        for (x = 0; x < length($0); x++) {
            for (i = 0; i < 3; i++) {
                mult_x = cos((angle + i * angle_phase) / 57.2976);
                mult_y = sin((angle + i * angle_phase) / 57.2976);
                hsv[1] = (((x * mult_x + y * mult_y) / (width + width_phase * i)) % 1 + 1 + (offset + offset_phase * i) / 360) % 1;
                hsv[2] = 0.8;
                hsv[3] = 0.9;

                hsv_to_rgb(hsv, trgb);
                rgb[i + 1] = trgb[i + 1];
            }

            put_rgb(rgb);
            printf("%s", substr($0, x + 1, 1));
        }
        print "\033[0m";
    }
    '
}

# }}}
##############################################################################
# {{{ md5sum

#examples:
# printf ss | md5sum
# cat FILE  | md5sum
# md5sum < FILE
md5sum() {
    if [ $# -eq 0 ] ; then
        if echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl md5 | rev | cut -d ' ' -f1 | rev
        else
            error "md5sum, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    else
        [ -e "$1" ] || {
            error "md5sum <PATH-OF-FILE>, PATH-OF-FILE[$1] is not exist."
            return 1
        }

        if command -v openssl > /dev/null ; then
             openssl md5    "$1" | cut -d ' ' -f2
        elif echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum "$1" | cut -d ' ' -f1
        else
            error "md5sum <PATH-OF-FILE>, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    fi
}

# }}}
##############################################################################
# {{{ sha256sum

#examples:
# printf ss | sha256sum
# cat FILE  | sha256sum
# sha256sum < FILE
sha256sum() {
    if [ $# -eq 0 ] ; then
        if echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl sha256 | rev | cut -d ' ' -f1 | rev
        else
            error "sha256sum, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    else
        [ -e "$1" ] || {
            error "sha256sum <PATH-OF-FILE>, PATH-OF-FILE[$1] is not exist."
            return 1
        }

        if command -v openssl > /dev/null ; then
             openssl sha256    "$1" | cut -d ' ' -f2
        elif echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum "$1" | cut -d ' ' -f1
        else
            error "sha256sum <PATH-OF-FILE>, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    fi
}

# file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>
  file_exists_and_sha256sum_matched() {
    [ -z "$1" ] && {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, <PATH-OF-FILE> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, <EXPECTED-SHA256SUM-OF-FILE> is not given."
        return 1
    }

    [ -e "$1" ] || {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, PATH-OF-FILE[$1] is not exist."
        return 1
    }

    [ "$(sha256sum $1)" = "$2" ]
}

# }}}
##############################################################################
# {{{ map

# 40   map name is not given.
# 41   map key  is not given.

# __map_name_ref <MAP-NAME>
  __map_name_ref() {
    if [ -z "$1" ] ; then
        error "__map_name_ref <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    printf "map_%s\n" "$(printf '%s\n' "$1" | md5sum)"
}

# __map_key_ref <MAP-NAME> <MAP-KEY>
  __map_key_ref() {
    if [ -z "$1" ] ; then
        error "__map_key_ref <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "__map_key_ref <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    printf "%s_key_%s\n" "$(__map_name_ref "$1")" "$(printf '%s\n' "$2" | md5sum)"
}

# map_contains <MAP-NAME> <MAP-KEY>
  map_contains() {
    if [ -z "$1" ] ; then
        error "map_contains <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_contains <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    for item in $(eval echo \$$(__map_name_ref "$1"))
    do
        if [ "$item" = "$2" ] ; then
            return 0
        fi
    done

    return 1
}

# map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>
  map_set() {
    if [ -z "$1" ] ; then
        error "map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>, <MAP-KEY> is not given."
        return 41
    fi

    map_contains "$1" "$2" || {
        unset __MAP_NAME_REF__
        __MAP_NAME_REF__="$(__map_name_ref "$1")"
        __MAP_NAME_REF_VALUE__="$(eval echo \$$__MAP_NAME_REF__)"
        eval "$__MAP_NAME_REF__=\"$__MAP_NAME_REF_VALUE__ $2\""
    }

    eval "$(__map_key_ref "$1" "$2")=$3"
}

# map_get <MAP-NAME> <MAP-KEY>
  map_get() {
    if [ -z "$1" ] ; then
        error "map_get <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_get <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    eval echo "\$$(__map_key_ref "$1" "$2")"
}

# map_remove <MAP-NAME> <MAP-KEY>
  map_remove() {
    if [ -z "$1" ] ; then
        error "map_remove <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_remove <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    unset __MAP_KEYS__
    __MAP_KEYS__="$(map_keys "$1")"

    unset $__MAP_NAME_REF__

    for item in $__MAP_KEYS__
    do
        if [ "$item" = "$2" ] ; then
            continue
        else
            eval "$__MAP_NAME_REF__='$(eval echo \$$__MAP_NAME_REF__) $item'"
        fi
    done

    eval "unset $(__map_key_ref "$1" "$2")"
}

# map_remove <MAP-NAME>
  map_clear() {
    if [ -z "$1" ] ; then
        error "map_clear <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    for item in $(eval echo "\$$__MAP_NAME_REF__")
    do
        eval "unset $(__map_key_ref "$1" "$item")"
    done

    eval "unset $__MAP_NAME_REF__"
}

# map_keys <MAP-NAME>
  map_keys() {
    if [ -z "$1" ] ; then
        error "map_keys <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    eval echo "\$$(__map_name_ref "$1")"
}

# map_size <MAP-NAME>
  map_size() {
    if [ -z "$1" ] ; then
        error "map_size <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    list_length $(map_keys "$1")
}

# }}}
##############################################################################
# {{{ fetch

# fetch <URL> [--silent] [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_SILENT

    if [ -z "$1" ] ; then
        error "fetch <URL> [OPTION]... , <URL> must not be empty."
        return 1
    else
        if [ "$COUNTRY" = 'china' ] ; then
            FETCH_URL="$(get_china_mirror_url "$1")"
        else
            FETCH_URL="$1"
        fi
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --silent)
                FETCH_SILENT=yes
                RUN_SILENT=yes
                ;;
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    error "fetch <URL> --output-dir=<DIR> , <DIR> must not be empty."
                    return 1
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    error "fetch <URL> --output-name=<NAME> , <NAME> must not be empty."
                    return 1
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    error "fetch <URL> --output-path=<FILEPATH> , <FILEPATH> must not be empty."
                    return 1
                fi
                ;;
            *)  error "fetch <URL> [OPTION]..., unrecognized option: $1

    fetch command usage:

    fetch <URL> [--silent] [--sha256=SHA256] <--output-path=PATH>
    fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
    fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
    fetch <URL> [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>"
                return 1
        esac
        shift
    done

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi

            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi

            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

            if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR" || return 1
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [    -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse 2> /dev/null ; then
                    run git pull || return 1
                    run git submodule update --recursive || return 1
                else
                    run cd .. || return 1
                    run rm -rf "$FETCH_OUTPUT_NAME" || return 1
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
                fi
            else
                if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                        success "$FETCH_OUTPUT_PATH already have been fetched."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH" || return 1
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command_exists_in_filesystem "$FETCH_TOOL" ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                if handle_dependency required exe curl ; then
                    FETCH_TOOL=curl
                else
                    return 1
                fi
            fi

            case $FETCH_TOOL in
                curl)
                    unset FETCH_TOOL_CURL_EXTRA_OPTIONS

                    if [ "$FETCH_SILENT" = yes ] ; then
                        FETCH_TOOL_CURL_OPTIONS='--no-progress-meter'
                    fi

                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    ;;
                wget)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    fi
                    ;;
                http)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    fi
                    ;;
                lynx)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'"
                    else
                        run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'"
                    fi
                    ;;
                aria2c)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'"
                    else
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'"
                    fi
                    ;;
                axel)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    fi
                    ;;
                *)  error "fetch() unimplementation: $FETCH_TOOL"
                    return 1
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" || {
                    error "sha256sum mismatch.\n    expect : $FETCH_SHA256\n    actual : $(sha256sum $FETCH_OUTPUT_PATH)"
                    return 1
                }
            fi
    esac
}

install_ca_certificates_on_netbsd() {
    # https://www.cambus.net/installing-ca-certificates-on-netbsd/
    if [ "$(uname)" = NetBSD ] ; then
        command -v mozilla-rootcerts > /dev/null || {
            if command -v pkgin > /dev/null ; then
                run $([ "$(whoami)" = root ] || printf 'sudo\n') pkgin -y install mozilla-rootcerts
            fi
        }
        run mozilla-rootcerts install || true
    fi
}

# }}}
##############################################################################
# {{{ get_china_mirror_url

# get_china_mirror_url <ORIGIN_URL>
get_china_mirror_url() {
    case $1 in
        *githubusercontent.com/*)
            printf "%s\n" "$1" | sed 's@githubusercontent.com/@githubusercontents.com/@'
            ;;
        *github.com/*)
            printf "%s\n" "$1" | sed 's@github.com/@hub.fastgit.org/@'
            ;;
        *)  printf '%s\n' "$1"
    esac
}

# }}}
##############################################################################
# {{{ __upgrade_self

# __upgrade_self <URL> [--china] [-x]
__upgrade_self() {
    set -e

    if [ -z "$1" ] ; then
        error "__upgrade_self <URL> [--china] [-x] , <URL> must not be empty."
        return 1
    else
        UPGRADE_SELF_URL="$1"
    fi

    shift

    unset XTRACE
    unset COUNTRY

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=yes
                set -x
                ;;
            --china)
                COUNTRY=china
                ;;
            *)  error "__upgrade_self <URL> [--china] [-x] , unrecognized argument: $arg" ; return 1
        esac
    done

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f $CURRENT_SCRIPT_FILEPATH)
        else
            handle_dependency required exe realpath
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$UPGRADE_SELF_URL" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf $WORKING_DIR
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ __integrate_zsh_completions

# __integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x]
__integrate_zsh_completions() {
    set -e

    if [ -z "$1" ] ; then
        error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x] , <URL> must not be empty."
        return 1
    else
        ZSH_COMPLETIONS_SCRIPT_URL="$1"
    fi

    shift

    unset XTRACE
    unset COUNTRY
    unset OUTPUT_DIR

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=yes
                set -x
                ;;
            --china)
                COUNTRY=china
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$OUTPUT_DIR" ] ; then
                    error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must not be empty."
                    return 1
                fi
                OUTPUT_DIR=$(globing "$OUTPUT_DIR")
                ;;
            *)  error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x] , unrecognized argument: $arg"
                return 1
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        else
            handle_dependency required exe realpath
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        fi
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$ZSH_COMPLETIONS_SCRIPT_URL" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf $WORKING_DIR

    printf '\n'
    note "${COLOR_YELLOW}you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ os

__get_os_kind_from_uname() {
    case $1 in
        msys*)    printf '%s\n' 'windows' ;;
        mingw32*) printf '%s\n' 'windows' ;;
        mingw64*) printf '%s\n' 'windows' ;;
        cygwin*)  printf '%s\n' 'windows' ;;
        *)        printf '%s\n' "$1"
    esac
}

__get_os_type_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_type_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f1 | tr A-Z a-z ;;
            *)   return 1
        esac
    fi
}

__get_os_version_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_version_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f2 ;;
            *)   return 1
        esac
    fi
}

# https://www.freedesktop.org/software/systemd/man/os-release.html
__get_os_type_from_etc_os_release() {
    if [ -e /etc/os-release ] ; then
        (
            . /etc/os-release || return 20
            if [ -z "$ID" ] ; then
                return 1
            else
                printf '%s\n' "$ID" | tr A-Z a-z
            fi
        )
    else
        return 1
    fi
}

__get_os_version_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        (
            . /etc/os-release || return 20
            if [ -z "$VERSION_ID" ] ; then
                printf '%s\n' 'rolling'
            else
                printf '%s\n' "$VERSION_ID"
            fi
        )
    else
        return 1
    fi
}

# https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html
__get_os_type_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --id | cut -f2 | tr A-Z a-z
    else
        return 1
    fi
}

__get_os_version_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --release | cut -f2
    else
        return 1
    fi
}

__get_os_type_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_type_from_etc_redhat_release "$(cat /etc/redhat-release)"
        else
            return 1
        fi
    else
        case $1 in
            'Red Hat Enterprise Linux release'*)
                printf '%s\n' rhel
                ;;
            'Fedora release'*)
                printf '%s\n' fedora
                ;;
            'CentOS release'*)
                printf '%s\n' centos
                ;;
            'CentOS Linux release'*)
                printf '%s\n' centos
                ;;
            *)  printf '%s\n' "$1" | cut -d ' ' -f1 | tr A-Z a-z
        esac
    fi
}

__get_os_version_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_version_from_etc_redhat_release $(cat /etc/redhat-release)
        else
            return 1
        fi
    else
        while [ -n "$1" ]
        do
            case $1 in
                [1-9]*) printf '%s\n' "$1"; return 0
            esac
            shift
        done
        return 1
    fi
}

__get_os_version_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.build.version.release
    else
        return 1
    fi
}

__get_os_arch_from_uname() {
    if command -v uname > /dev/null ; then
        uname -m 2> /dev/null
    else
        return 1
    fi
}

__get_os_arch_from_arch() {
    if command -v arch > /dev/null ; then
        arch
    else
        return 1
    fi
}

__get_os_type_from_os_kind() {
    case $1 in
        darwin)  printf '%s\n' macos ;;
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' android
            else
                __get_os_type_from_etc_redhat_release ||
                __get_os_type_from_etc_os_release ||
                __get_os_type_from_lsb_release ||
                __get_os_type_from_uname_a
            fi
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_name_from_os_type() {
    case $1 in
        debian)  printf '%s\n' 'Debian' ;;
        ubuntu)  printf '%s\n' 'Ubuntu' ;;
        linuxmint) printf '%s\n' 'LinuxMint' ;;
        centos)  printf '%s\n' 'CentOS' ;;
        fedora)  printf '%s\n' 'Fedora' ;;
        rhel)    printf '%s\n' 'RHEL' ;;
        opensuse-leap)
                 printf '%s\n' 'openSUSE-Leap' ;;
        gentoo)  printf '%s\n' 'Gentoo' ;;
        manjaro) printf '%s\n' 'Manjaro' ;;
        alpine)  printf '%s\n' 'AlpineLinux' ;;
        arch)    printf '%s\n' 'ArchLinux' ;;
        void)    printf '%s\n' 'VoidLinux' ;;
        freebsd) printf '%s\n' 'FreeBSD' ;;
        netbsd)  printf '%s\n' 'NetBSD' ;;
        openbsd) printf '%s\n' 'OpenBSD' ;;
        macos)   printf '%s\n' 'macOS' ;;
        android) printf '%s\n' 'Android' ;;
        windows)
            systeminfo | sed -n '/OS Name:/p' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//'
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_version_from_os_kind() {
    case $1 in
        freebsd) freebsd-version ;;
        openbsd) uname -r ;;
        netbsd)  uname -r ;;
        darwin)  sw_vers -productVersion ;;
        linux)
            __get_os_version_from_etc_redhat_release ||
            __get_os_version_from_etc_os_release ||
            __get_os_version_from_lsb_release ||
            __get_os_version_from_getprop ||
            __get_os_version_from_uname_a
            ;;
        windows)
            systeminfo | sed -n '/OS Version:/p' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' | cut -d ' ' -f1
            ;;
    esac
}

__get_os_sub_system() {
    case $(uname | tr A-Z a-z) in
        msys*)    printf '%s\n' "msys"    ;;
        mingw32*) printf '%s\n' "mingw32" ;;
        mingw64*) printf '%s\n' "mingw64" ;;
        cygwin*)  printf '%s\n' 'cygwin'  ;;
        *)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                if [ -n "$TERMUX_VERSION" ] ; then
                    printf '%s\n' termux
                fi
            fi
    esac
}

__get_os_arch() {
    __get_os_arch_from_uname ||
    __get_os_arch_from_arch
}

__get_os_libc_from_os_kind() {
    if [ "$1" = linux ] ; then
        if [ "$(uname -o 2>/dev/null)" = Android ] ; then
            printf '%s\n' bionic
            return 0
        fi

        # https://pubs.opengroup.org/onlinepubs/7908799/xcu/getconf.html
        if command -v getconf > /dev/null ; then
            if getconf GNU_LIBC_VERSION > /dev/null 2>&1 ; then
                printf '%s\n' glibc
                return 0
            fi
        fi

        if command -v ldd > /dev/null ; then
            if command -v grep > /dev/null ; then
                if ldd --version 2>&1 | head -n 1 | grep -q GLIBC ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if ldd --version 2>&1 | head -n 1 | grep -q musl ; then
                    printf '%s\n' musl
                    return 0
                fi
            elif command -v sed > /dev/null ; then
                if [ -n "$(ldd --version 2>&1 | head -n 1 | sed -n '/GLIBC/p')" ] ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if [ -n "$(ldd --version 2>&1 | head -n 1 | sed -n '/musl/p')"  ] ; then
                    printf '%s\n' musl
                    return 0
                fi
            fi
        fi

        return 1
    fi
}

# https://stackoverflow.com/questions/45181115/portable-way-to-find-the-number-of-processors-cpus-in-a-shell-script
__get_os_ncpu() {
    case "$(uname)" in
        Darwin) sysctl -n machdep.cpu.thread_count ;;
        *BSD)   sysctl -n hw.ncpu ;;
        *)  if command nproc --version > /dev/null 2>&1 ; then
                command nproc
            elif test -f /proc/cpuinfo ; then
                if command -v grep > /dev/null ; then
                    grep -c processor /proc/cpuinfo
                elif command -v sed > /dev/null && command -v wc > /dev/null ; then
                    sed -n '/^processor/p' /proc/cpuinfo | wc -l
                else
                    printf '%s\n' 4
                fi
            else
                printf '%s\n' 4
            fi
    esac
}

os() {
    if [ $# -eq 0 ] ; then
        printf "current-machine-os-kind : %s\n" "$(os kind)"
        printf "current-machine-os-type : %s\n" "$(os type)"
        printf "current-machine-os-name : %s\n" "$(os name)"
        printf "current-machine-os-vers : %s\n" "$(os vers)"
        printf "current-machine-os-arch : %s\n" "$(os arch)"
        printf "current-machine-os-ncpu : %s\n" "$(os ncpu)"
        printf "current-machine-os-euid : %s\n" "$(os euid)"
        printf "current-machine-os-libc : %s\n" "$(os libc)"
        printf "current-machine-os-subs : %s\n" "$(os subs)"
    elif [ $# -eq 1 ] ; then
        case $1 in
            -h|--help)
                cat <<'EOF'
os -h | --help
os -V | --version
os kind
os type
os name
os vers
os arch
os ncpu
os euid
os libc
os subs
EOF
                ;;
            -V|--version)
                printf "%s\n" '2021.10.01.03'
                ;;
            kind)
                __get_os_kind_from_uname $(uname | tr A-Z a-z)
                ;;
            type)
                __get_os_type_from_os_kind $(os kind)
                ;;
            name)
                __get_os_name_from_os_type $(os type)
                ;;
            vers)
                __get_os_version_from_os_kind $(os kind)
                ;;
            subs)
                __get_os_sub_system
                ;;
            arch)
                __get_os_arch
                ;;
            ncpu)
                __get_os_ncpu
                ;;
            euid)
                id -u
                ;;
            libc)
                __get_os_libc_from_os_kind $(os kind)
                ;;
            *)  printf '%s\n' "unrecognized argument: $1" >&2; return 1
        esac
    else
        printf '%s\n' "os command only support one argument." >&2; return 1
    fi
}

# }}}
##############################################################################
# {{{ version

version_of_python_module() {
    unset PIP_COMMAND
    PIP_COMMAND=$(command -v pip3 || command -v pip)
    if [ -z "$PIP_COMMAND" ] ; then
        error "can't found pip command."
        return 1
    else
        "$PIP_COMMAND" show $1 | sed -n '/Version:/p' | cut -d ' ' -f2
    fi
}

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
      gclient) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       ccache) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         bear) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmake) "$1" --version 2> /dev/null | head -n 1 | cut -d '+' -f1 | cut -d 'v' -f2 ;;
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         rake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       rustc)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
     patchelf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     xgettext) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     realpath) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
  intltoolize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
          adb) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     makeinfo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
    gtkdocize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
 glib-mkenums) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 glib-compile-resources)
               "$1" --version ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         java) "$1"  -version 2>&1 | head -n 1 | cut -d ' ' -f3 | sed 's/"//g' ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) printf '%s\n' "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) printf '%s\n' "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
          lua) "$1" -v 2>/dev/null | head -n 1 | cut -d ' ' -f2 ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      hexdump) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      sqlite3) "$1"  -version 2> /dev/null | head -n 1 | cut -d ' ' -f1 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    printf '%s\n' "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    printf '%s\n' "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  printf '%s\n' | (sort -V > /dev/null 2>&1) ; then
        printf '%s\n' "$@" | tr ' ' '\n' | sort -V
    else
        printf '%s\n' "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  error "version_compare: $2: not supported operator." ; return 1
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

# }}}
##############################################################################
# {{{ package manager wrapper, aka pmw

# https://cygwin.com/packages/package_list.html
__pmw_get_available_package_name_by_command_name_choco() {
    case $1 in
        go)   echo 'golang' ;;
        cc|gcc|c++|g++)
              echo 'gcc-g++';;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
       gmake) echo 'make'   ;;
         gm4) echo 'm4'     ;;
        gsed) echo 'gnu-sed';;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    sphinx-build) echo 'python38-sphinx' ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pkg_add() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
    realpath) echo 'coreutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    pip3|pip) echo 'py3-pip' ;;
    makeinfo) echo 'texinfo' ;;
    libtool|libtoolize|glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|autoreconf-2.69|autoconf-2.69)
              echo "autoconf-2.69p3" ;;
    automake|autoheader|automake-1.16|autoheader-1.16)
            if [ "$NATIVE_OS_VERS" = '6.9' ] ; then
                echo "automake-1.16.3"
            else
                echo "automake-1.16.2"
            fi
            ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    autopoint)    echo "gettext" ;;
     xgettext)    echo "gettext" ;;
    intltoolize)  echo "intltool";;
    gtkdocize)    echo "gtk-doc" ;;
    pkg-config)   echo "pkgconf" ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *) echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pkgin() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo 'py38-pip' ;;
    python3)  echo 'python38' ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pkg() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
        java) echo 'openjdk-17' ;;
         lua) echo 'lua54' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo 'py38-pip' ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_emerge() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'media-gfx/graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    xz)       echo 'xz-utils' ;;
    tree)     echo 'app-text/tree' ;;
    rst2man|rst2html)
                  echo "docutils" ;;
    sphinx-build) echo "sphinx" ;;
    pip3|pip)     echo "dev-python/pip" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pacman_internal() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    makeinfo) echo 'texinfo'  ;;
    hexdump)  echo 'util-linux' ;;
    rst2man|rst2html)
                  echo "python-docutils" ;;
    sphinx-build) echo "python-sphinx" ;;
    pip3|pip)     echo "python-pip" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__mingw_w64_i686() {
    if pacman -S -i "mingw-w64-i686-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-i686-$1"
    else
        echo "$1"
    fi
}

__mingw_w64_x86_64() {
    if pacman -S -i "mingw-w64-x86_64-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-x86_64-$1"
    else
        echo "$1"
    fi
}

__pmw_get_available_package_name_by_command_name_pacman() {
    if [ "$1" = 'make' ] || [ "$1" = 'gmake' ] ; then
        echo make
        return 1
    fi
    case $NATIVE_OS_SUBS in
        mingw32) __mingw_w64_i686   $(__pmw_get_available_package_name_by_command_name_pacman_internal "$1") ;;
        mingw64) __mingw_w64_x86_64 $(__pmw_get_available_package_name_by_command_name_pacman_internal "$1") ;;
        *) __pmw_get_available_package_name_by_command_name_pacman_internal "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_xbps() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip|pip3) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    glib-mkenums) echo 'glib2' ;;
    glib-compile-resources)
                  echo 'glib2' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_apk() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo 'py3-pip'  ;;
    rst2man|rst2html)
              echo "py3-docutils" ;;
    sphinx-build) echo "sphinx" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *) echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_zypper() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
         7zr) echo 'p7zip'    ;;
      7z|7za)
            if [ "$NATIVE_OS_TYPE" = 'opensuse-leap' ] ; then
                if version_match "$NATIVE_OS_VERS" gt 15.1 ; then
                    echo 'p7zip-full'
                else
                    echo 'p7zip'
                fi
            else
                echo 'p7zip'
            fi
            ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz-gd' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    rst2man|rst2html)
                  echo "python3-docutils" ;;
    sphinx-build) echo "python3-Sphinx" ;;
    pip3|pip)     echo "python3-pip" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    autopoint)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_dnf() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    patchelf)
        # EPEL repo is shipped with Fedora
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            echo 'ccache'
        else
            echo 'epel:patchelf'
        fi
        ;;
    ccache)
        # EPEL repo is shipped with Fedora
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            echo 'ccache'
        else
            echo 'epel:ccache'
        fi
        ;;
    pkg-config)
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            if [ "$NATIVE_OS_VERS" -ge 34 ] ; then
                echo 'pkgconf-pkg-config'
            else
                echo 'pkg-config'
            fi
        else
            echo 'pkg-config'
        fi
        ;;
    rst2man|rst2html)
                  echo "python3-docutils" ;;
    sphinx-build) echo "python3-sphinx" ;;
    glib-mkenums) echo 'glib2-devel' ;;
    glib-compile-resources)
                  echo 'glib2-devel' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_yum() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    patchelf) echo 'epel:patchelf' ;;
    ccache)   echo 'epel:ccache' ;;
    sphinx-build) echo "python-sphinx" ;;
    glib-mkenums) echo 'glib2-devel' ;;
    glib-compile-resources)
                  echo 'glib2-devel' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_apt_get() {
    __pmw_get_available_package_name_by_command_name_apt $@
}

__pmw_get_available_package_name_by_command_name_apt() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
        java) echo 'openjdk-17-jdk' ;;
         lua) echo 'lua5.3';;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
        xz)   echo 'xz-utils' ;;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
         7zr) echo 'p7zip'    ;;
      7z|7za) echo 'p7zip-full' ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'bsdmainutils';;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    grpc_cpp_plugin)
              echo "libgrpc" ;;
    glib-mkenums)
              echo 'libglib2.0-dev' ;;
    glib-compile-resources)
                  echo 'libglib2.0-dev-bin' ;;
    libtoolize|glibtoolize)
                echo "libtool"  ;;
    libtool)    echo "libtool-bin" ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc-tools" ;;
    gdk-pixbuf-query-loaders)
                echo 'libgdk-pixbuf2.0-bin' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        ninja)
            if [ "$NATIVE_OS_SUBS" = termux ] ; then
                echo ninja
            else
                echo ninja-build
            fi
            ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_brew() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    rst2man.py|rst2html.py)
              echo "docutils" ;;
    grpc_cpp_plugin)
              echo "grpc" ;;
    glib-mkenums)
              echo 'glib' ;;
    glib-compile-resources)
              echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    python|python3)
                echo 'python@3.9' ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_cargo() {
    case $1 in
        cargo-capi|cargo-cbuild|cargo-cinstall|cargo-ctest)
            echo 'cargo-c' ;;
    esac
}

__pmw_get_available_package_name_by_command_name_pip3() {
    __pmw_get_available_package_name_by_command_name_pip $@
}

__pmw_get_available_package_name_by_command_name_pip() {
    case $1 in
        sphinx-build) echo "sphinx"   ;;
        rst2man.py)   echo "docutils" ;;
        meson)        echo "meson" ;;
    esac
}

__pmw_get_available_pm_list() {
    for pm in brew pkg apt apt-get dnf yum zypper apk xbps emerge pacman choco pkgin pkg_add cargo
    do
        case $pm in
            apt)
                if command_exists_in_filesystem apt && apt show apt > /dev/null 2>&1 ; then
                    printf '%s\n' apt
                fi
                ;;
            xbps)
                if command_exists_in_filesystem xbps-install ; then
                    printf '%s\n' xbps
                fi
                ;;
            *)
                if command_exists_in_filesystem "$pm" ; then
                    printf '%s\n' "$pm"
                fi
        esac
    done
}

# __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>]
# __pmw_install_the_given_package apt default make ge 3.80
# __pmw_install_the_given_package apt default make
# __pmw_install_the_given_package yum epel    ccache
# __pmw_install_the_given_package dnf epel    ccache
__pmw_install_the_given_package() {
    [ -z "$1" ] && {
        error "USAGE: __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>] , <PM> must not be empty."
        return 1
    }

    [ -z "$2" ] && {
        error "USAGE: __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>] , <REPO> must not be empty."
        return 1
    }

    [ -z "$3" ] && {
        error "USAGE: __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>] , <PKG> must not be empty."
        return 1
    }

    {
        case $1 in
            apk)     run "$sudo" apk    update    ;;
            zypper)  run "$sudo" zypper update -y ;;
            pacman)  run "$sudo" pacman -Syy --noconfirm ;;
            dnf|yum)
                case $2 in
                    default) run "$sudo" "$1" -y update ;;
                    epel)
                        if [ epel = "$("$1" repolist | cut -d ' ' -f1 | sed -n '/^epel$/p')" ] ; then
                            run "$sudo" "$1" --enablerepo=epel -y update
                        else
                            run "$sudo" "$1"                   -y update  &&
                            run "$sudo" "$1"                   -y install epel-release &&
                            run "$sudo" "$1" --enablerepo=epel -y update
                        fi
                        ;;
                esac
                ;;
            apt-get|apt)
                case $2 in
                    default) run "$sudo" "$1" -y update ;;
                    ppa:*)   run "$sudo" "$1" -y update ;;
                    *)       error "$1: unrecognized repo: $2" ; return 1 ;;
                esac
        esac
    } || return 1

    __pmw_is_the_given_package_available $@ || return 1

    note "${COLOR_GREEN}$(shiftn 2 $@)${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}$1${COLOR_OFF}"

    case $1 in
        pip3)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip3 install --user -U "$3" ;;
                *)          run pip3 install        -U "$3"
            esac
            ;;
        pip)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip  install --user -U "$3" ;;
                *)          run pip  install        -U "$3"
            esac
            ;;
        brew)
            if run brew install "$3" ; then
                unset __HOMEBREW_PKG_PREFIX__
                __HOMEBREW_PKG_PREFIX__="$(brew --prefix "$3")"
                if [ "$(brew info --json=v2 "$3" | sed -n '/"keg_only":/p' | sed 's/ //g' | cut -d: -f2 | sed 's/,//')" = 'true' ] ; then
                    if [ -d "$__HOMEBREW_PKG_PREFIX__/bin" ] ; then
                        export PATH="$__HOMEBREW_PKG_PREFIX__/bin:$PATH"
                    fi
                    if [ -d "$__HOMEBREW_PKG_PREFIX__/sbin" ] ; then
                        export PATH="$__HOMEBREW_PKG_PREFIX__/sbin:$PATH"
                    fi
                fi
                if [ -d "$__HOMEBREW_PKG_PREFIX__/libexec/gnubin" ] ; then
                    export PATH="$__HOMEBREW_PKG_PREFIX__/libexec/gnubin:$PATH"
                fi
                unset __HOMEBREW_PKG_PREFIX__
            else
                return 1
            fi
            ;;
        pkg)     run $sudo pkg install -y "$3" ;;
        pkgin)   run $sudo pkgin -y install "$3" ;;
        pkg_add) run $sudo pkg_add "$3" ;;
        apt)     run $sudo apt -y install "$3" ;;
        apt-get) run $sudo apt-get -y install "$3" ;;
        dnf)     run $sudo dnf -y install "$3" ;;
        yum)     run $sudo yum -y install "$3" ;;
        zypper)  run $sudo zypper install -y "$3" ;;
        apk)     run $sudo apk add "$3" ;;
        xbps)    run $sudo xbps-install -Syu "$3" ;;
        pacman)  run $sudo pacman -Syy --noconfirm && run $sudo pacman -S --noconfirm "$3" ;;
        choco)   run choco install -y --source cygwin "$3" ;;
        cargo)   run cargo install "$3" ;;
        emerge)
            if [ "$3" = 'media-gfx/graphviz' ] ; then
                $sudo cat >> /etc/portage/package.use/zzz_autounmask <<EOF
# required by media-gfx/graphviz-2.44.1-r1::gentoo
# required by media-gfx/graphviz (argument)
>=media-libs/gd-2.3.1 fontconfig truetype
EOF
            fi
            run $sudo emerge "$3" ;;
    esac
}

# check if the give package specification is available in specified package manager's repo
#
# package specification's form: <PKG> [OP VERSION]
#
# OP:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# __pmw_is_the_given_package_available <PM> <REPO> <PKG> [OP VERSION]
#
# __pmw_is_the_given_package_available apt default automake eq 1.16.0
# __pmw_is_the_given_package_available apt default automake lt 1.16.0
# __pmw_is_the_given_package_available apt default automake gt 1.16.0
# __pmw_is_the_given_package_available apt default automake le 1.16.0
# __pmw_is_the_given_package_available apt default automake ge 1.16.0
# __pmw_is_the_given_package_available apt default automake
__pmw_is_the_given_package_available() {
    if [ $# -eq 3 ] ; then
        case $1 in
            pkg) pkg show "$3" > /dev/null 2>&1 ;;
            apt) apt show "$3" > /dev/null 2>&1 ;;
            apk) apk info "$3" > /dev/null 2>&1 ;;
            yum) yum info "$3" > /dev/null 2>&1 ;;
            dnf) dnf info "$3" > /dev/null 2>&1 ;;
            brew) brew info "$3" > /dev/null 2>&1 ;;
            xbps) xbps-query -R "$3" > /dev/null 2>&1 ;;
            pacman) pacman -Ss "^$3$" > /dev/null 2>&1 ;;
            zypper) [ "$(zypper info "$3" 2>&1 | tail -n 1)" != "package '$3' not found." ] ;;
            emerge)
                case $3 in
                    */*) [ "$(emerge -s "%@^$3$" 2>&1 | tail -n 2 | head -n 1)" != '\[ Applications found : 0 \]' ] ;;
                    *)   [ "$(emerge -s "%^$3$"  2>&1 | tail -n 2 | head -n 1)" != '\[ Applications found : 0 \]' ]
                esac
                ;;
        esac
    elif [ $# -eq 5 ] ; then
        __pmw_is_the_given_package_available "$1" "$2" "$3" && version_match "$(__pmw_get_available_package_version_by_package_name "$1" "$3")" "$4" "$5"
    else
        error "USAGE:  __pmw_is_the_given_package_available <PM> <REPO> <PKG> [OP VERSION]\n    ACTUAL: __pmw_is_the_given_package_available $@"
        return 1
    fi
}

# __pmw_get_available_package_version_by_package_name <PM> <PKG>
# __pmw_get_available_package_version_by_package_name apt automake
__pmw_get_available_package_version_by_package_name() {
    case $1 in
        pkg)   pkg show "$2" 2> /dev/null | sed -n '/Version: /p' | head -n 1 | cut -d ' ' -f2 | cut -d- -f1  | cut -d~ -f1 | sed 's/[0-9]://' ;;
        apt)   apt show "$2" 2> /dev/null | sed -n '/Version: /p' | head -n 1 | cut -d ' ' -f2 | cut -d- -f1  | cut -d~ -f1 | sed 's/[0-9]://' ;;
        apk)   apk info "$2" 2> /dev/null | head -n 1 | cut -d ' ' -f1 | cut -d- -f2 ;;
        yum)   yum info "$2" 2> /dev/null | sed -n '/Version     :/p'  | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        dnf)   dnf info "$2" 2> /dev/null | sed -n '/Version      :/p' | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        brew) brew info "$2" 2> /dev/null | head -n 1 | sed 's|stable ||' | cut -d ' ' -f2 | cut -d ',' -f1 ;;
        xbps) xbps-query -R --property=pkgver "$2" | cut -d- -f2 | cut -d_ -f1 ;;
        pacman) pacman -Ss "^$2$" 2> /dev/null | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        zyyper) zyyper info "$2" 2> /dev/null | sed -n '/Version        :/p' | sed 's/Version        : \(.*\)/\1/' | cut -d- -f1 ;;
        emerge)
            case $2 in
                */*) emerge -s "%@^$2$" 2> /dev/null | sed -n '/Latest version available:/p' | cut -d: -f2 ;;
                *)   emerge -s "%^$2$"  2> /dev/null | sed -n '/Latest version available:/p' | cut -d: -f2 ;;
            esac
    esac
}

# }}}
##############################################################################
# {{{ uppm => universal prebuild package manager

__uppm_list_the_available_packages_in_the_world() {
    cat <<EOF
linux |x86_64|glibc|python3 |3.9.5 |5d9b13e38878292f18a41188bd530d059c7c2b1e64eed29cb5c6d38b0a94ad0a|https://github.com/leleliu008/python-prebuild/releases/download/3.9.5/python-3.9.5-x86_64-linux-glibc.tar.xz

linux |x86_64|glibc|git     |2.30.2|61e545ef05e41565292c2e909e5b39e4eb8e60a4e729db06a1ddea3b44f89241|https://github.com/leleliu008/git-prebuild/releases/download/2.30.2/git-2.30.2-x86_64-linux-glibc.tar.xz

linux |x86_64|glibc|autoconf|2.69  |3b29f52cabe26ba0217825b1cf25b8d4163b6e6afcce1cce70027e0bc33a0860|https://github.com/leleliu008/autoconf-prebuild/releases/download/2.69/autoconf-2.69-glibc-linux-x86_64.tar.gz

linux |x86_64|glibc|cmake   |3.21.4|eddba9da5b60e0b5ec5cbb1a65e504d776e247573204df14f6d004da9bc611f9|https://github.com/Kitware/CMake/releases/download/v3.21.4/cmake-3.21.4-linux-x86_64.tar.gz
darwin|  -   |  -  |cmake   |3.21.4|f818a10fe625b215e31d0c29c19a6563fb5f51ed7cc7727e5011626c11ea321a|https://github.com/Kitware/CMake/releases/download/v3.21.4/cmake-3.21.4-macos-universal.tar.gz

linux |x86_64|  -  |ninja   |1.10.2|763464859c7ef2ea3a0a10f4df40d2025d3bb9438fcb1228404640410c0ec22d|https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip
darwin|x86_64|  -  |ninja   |1.10.2|6fa359f491fac7e5185273c6421a000eea6a2f0febf0ac03ac900bd4d80ed2a5|https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-mac.zip

linux |x86_64|  -  |golang  |1.18|e85278e98f57cdb150fe8409e6e5df5343ecb13cebf03a5d5ff12bd55a80264f|https://dl.google.com/go/go1.18.linux-amd64.tar.gz
darwin|x86_64|  -  |golang  |1.18|70bb4a066997535e346c8bfa3e0dfe250d61100b17ccc5676274642447834969|https://dl.google.com/go/go1.18.darwin-amd64.tar.gz
darwin|arm64 |  -  |golang  |1.18|9cab6123af9ffade905525d79fc9ee76651e716c85f1f215872b5f2976782480|https://dl.google.com/go/go1.18.darwin-arm64.tar.gz

linux |arm64 |glibc|jdk     |17.0.1|a5e954a4e89b50277f20345034aea0ccf06f53705d4ec586b268b14ff42468f7|https://download.oracle.com/java/17/archive/jdk-17.0.1_linux-aarch64_bin.tar.gz
linux |x86_64|glibc|jdk     |17.0.1|6f25bcb94d3e22fb52a4632c74e03b403834e81b68701ab7ecd900fb9cd89f43|https://download.oracle.com/java/17/archive/jdk-17.0.1_linux-x64_bin.tar.gz
darwin|arm64 |  -  |jdk     |17.0.1|8e5f240705bdf37ed831abc8c52cc05afe71721a6bc26dd977b6efd01b5ebef7|https://download.oracle.com/java/17/archive/jdk-17.0.1_macos-aarch64_bin.tar.gz
darwin|x86_64|  -  |jdk     |17.0.1|b8905d88a14e60f873064a8b25737e2ec2e3688611adbf21f3a5dd5c8742797d|https://download.oracle.com/java/17/archive/jdk-17.0.1_macos-x64_bin.tar.gz

linux |x86_64|  -  |android-sdk|7583922|124f2d5115eee365df6cf3228ffbca6fc3911d16f8025bebd5b1c6e2fcfa7faf|https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip
darwin|  -   |  -  |android-sdk|7583922|6929a1957f3e71008adfade0cebd08ebea9b9f506aa77f1849c7bdc3418df7cf|https://dl.google.com/android/repository/commandlinetools-mac-7583922_latest.zip

linux |x86_64|glibc|file|5.41|cd99dbd24fc55e79d5bab627e591219891acce97f787cafc8eb2d5c41b1d4db7|https://github.com/leleliu008/test/releases/download/20220409-2015/file-5.41-x86_64-linux-glibc.tar.xz
EOF
}

# __uppm_is_the_given_package_available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>]
__uppm_is_the_given_package_available() {
    [ -z "$1" ] && {
        error "uppm is-available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], <PACKAGE-NAME> must not be empty."
        return 1
    }

    if [ $# -ge 3 ] ; then
        case $2 in
            eq|ne|lt|ge|lt|gt) ;;
            *)  error "uppm is-available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], unrecognized argument: $2"
                return 1
        esac

        if [ -z "$3" ] ; then
            error "uppm is-available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>],  <VERSION> must not be empty."
            return 1
        fi
    fi

    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages_in_the_world | sed 's/ //g')
    do
        unset UPPM_PKG_OS_KIND
        unset UPPM_PKG_OS_ARCH
        unset UPPM_PKG_OS_LIBC

        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS

        if [ -z "$UPPM_PKG_LINE" ] ; then
            continue
        fi

        UPPM_PKG_OS_KIND=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)

        if [ "$UPPM_PKG_OS_KIND" != '-' ] && [ "$UPPM_PKG_OS_KIND" != "$NATIVE_OS_KIND" ] ; then
            continue
        fi

        UPPM_PKG_OS_ARCH=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)

        if [ "$UPPM_PKG_OS_ARCH" != '-' ] && [ "$UPPM_PKG_OS_ARCH" != "$NATIVE_OS_ARCH" ] ; then
            continue
        fi

        UPPM_PKG_OS_LIBC=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)

        if [ "$UPPM_PKG_OS_LIBC" != '-' ] && [ "$UPPM_PKG_OS_LIBC" != "$NATIVE_OS_LIBC" ] ; then
            continue
        fi

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)

        if [ "$UPPM_PKG_NAME" != "$1" ] ; then
            continue
        fi

        if [ $# -ge 3 ] ; then
            UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f5)
            version_match "$UPPM_PKG_VERS" "$2" "$3" || continue
        fi

        return 0
    done

    return 1
}

__uppm_is_the_given_package_installed() {
    [ -f "$HOME/.uppm/install.d/$1/installed-metadata" ]
}

# __uppm_list_the_available_packages
# __uppm_list_the_available_packages <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>]
__uppm_list_the_available_packages() {
    if [ $# -ge 1 ] ; then
        if [ -z "$1" ] ; then
            error "uppm ls-available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], <PACKAGE-NAME> must not be empty."
            return 1
        fi
    fi

    if [ $# -ge 3 ] ; then
        case $2 in
            eq|ne|lt|ge|lt|gt) ;;
            *)  error "uppm ls-available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], unrecognized argument: $2"
                return 1
        esac

        if [ -z "$3" ] ; then
            error "uppm ls-available <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], <VERSION> must not be empty."
            return 1
        fi
    fi

    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages_in_the_world | sed 's/ //g')
    do
        unset UPPM_PKG_OS_KIND
        unset UPPM_PKG_OS_ARCH
        unset UPPM_PKG_OS_LIBC

        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS
        unset UPPM_PKG_SHA_
        unset UPPM_PKG_URL_

        if [ -z "$UPPM_PKG_LINE" ] ; then
            continue
        fi

        UPPM_PKG_OS_KIND=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)

        if [ "$UPPM_PKG_OS_KIND" != '-' ] && [ "$UPPM_PKG_OS_KIND" != "$NATIVE_OS_KIND" ] ; then
            continue
        fi

        UPPM_PKG_OS_ARCH=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)

        if [ "$UPPM_PKG_OS_ARCH" != '-' ] && [ "$UPPM_PKG_OS_ARCH" != "$NATIVE_OS_ARCH" ] ; then
            continue
        fi

        UPPM_PKG_OS_LIBC=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)

        if [ "$UPPM_PKG_OS_LIBC" != '-' ] && [ "$UPPM_PKG_OS_LIBC" != "$NATIVE_OS_LIBC" ] ; then
            continue
        fi

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)
        UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f5)
        UPPM_PKG_SHA_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f6)
        UPPM_PKG_URL_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f7)

        if [ $# -eq 0 ] ; then
            printf '%s\n' "$UPPM_PKG_LINE"
            continue
        fi

        if [ $# -eq 1 ] ; then
            if [ "$UPPM_PKG_NAME" = "$1" ] ; then
                printf '%s\n' "$UPPM_PKG_LINE"
            fi
            continue
        fi

        if [ $# -eq 3 ] ; then
            if [ "$UPPM_PKG_VERS" -$2 "$3" ] ; then
                printf '%s\n' "$UPPM_PKG_LINE"
                if [ "$2" = 'eq' ] ; then
                    break
                fi
            fi
            continue
        fi
    done
}

__uppm_list_the_installed_packages() {
    :
}

# __uppm_show_infomation
# __uppm_show_infomation <PACKAGE-NAME>
__uppm_show_infomation_of_the_given_package() {
    __uppm_list_the_available_packages $@
}

__uppm_get_filetype_from_url() {
    case $1 in
        *.zip)     printf '%s\n' zip    ;;
        *.tar.xz)  printf '%s\n' tar.xz ;;
        *.tar.gz)  printf '%s\n' tar.gz ;;
        *.tar.lz)  printf '%s\n' tar.lz ;;
        *.tar.bz2) printf '%s\n' tar.bz2;;
        *.tgz)     printf '%s\n' tar.gz ;;
        *.txz)     printf '%s\n' tar.xz ;;
        *.c)       printf '%s\n' c      ;;
        *.cc)      printf '%s\n' cxx    ;;
        *.cxx)     printf '%s\n' cxx    ;;
        *.cpp)     printf '%s\n' cxx    ;;
    esac
}

# __uppm_fetch
# __uppm_fetch <PACKAGE-NAME>
# __uppm_fetch <PACKAGE-NAME> eq|ne|le|gr|lt|gt <VERSION>
__uppm_fetch() {
    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages $@)
    do
        unset UPPM_PKG_OS_KIND
        unset UPPM_PKG_OS_ARCH
        unset UPPM_PKG_OS_LIBC

        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS
        unset UPPM_PKG_SHA_
        unset UPPM_PKG_URL_

        UPPM_PKG_OS_KIND=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)
        UPPM_PKG_OS_ARCH=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)
        UPPM_PKG_OS_LIBC=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)
        UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f5)
        UPPM_PKG_SHA_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f6)
        UPPM_PKG_URL_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f7)

        UPPM_PKG_FILETYPE=$(__uppm_get_filetype_from_url "$UPPM_PKG_URL_")

        UPPM_PKG_FILENAME="$UPPM_PKG_NAME-$UPPM_PKG_VERS"

        [ "$UPPM_PKG_OS_KIND" != '-' ]  && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME-$UPPM_PKG_OS_KIND"
        [ "$UPPM_PKG_OS_ARCH" != '-' ]  && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME-$UPPM_PKG_OS_ARCH"
        [ "$UPPM_PKG_OS_LIBC" != '-' ]  && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME-$UPPM_PKG_OS_LIBC"

        [ -n "$UPPM_PKG_FILETYPE" ]     && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME.$UPPM_PKG_FILETYPE"

        UPPM_PKG_FILEPATH="$HOME/.uppm/downloads/$UPPM_PKG_FILENAME"

        fetch "$UPPM_PKG_URL_" --sha256="$UPPM_PKG_SHA_" --output-path="$UPPM_PKG_FILEPATH"
    done
}

# __uppm_install_the_given_package <PACKAGE-NAME> [eq|ne|le|ge|lt|gt <VERSION>]
__uppm_install_the_given_package() {
    [ -z "$1" ] && {
        error "uppm install <PACKAGE-NAME> [eq|ne|le|ge|lt|gt <VERSION>], <PACKAGE-NAME> must not be empty."
        return 1
    }

    if [ $# -ge 3 ] ; then
        case $2 in
            eq|ne|lt|ge|lt|gt) ;;
            *)  error "uppm install <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], unrecognized argument: $2"
                return 1
        esac

        if [ -z "$3" ] ; then
            error "uppm install <PACKAGE-NAME> [eq|ne|le|gr|lt|gt <VERSION>], <VERSION> must not be empty."
            return 1
        fi
    fi

    unset UPPM_PKG_LINE

    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages_in_the_world | sed 's/ //g')
    do
        unset UPPM_PKG_OS_KIND
        unset UPPM_PKG_OS_ARCH
        unset UPPM_PKG_OS_LIBC

        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS

        [ -z "$UPPM_PKG_LINE" ] && continue

        UPPM_PKG_OS_KIND=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)

        if [ "$UPPM_PKG_OS_KIND" != '-' ] && [ "$UPPM_PKG_OS_KIND" != "$NATIVE_OS_KIND" ] ; then
            continue
        fi

        UPPM_PKG_OS_ARCH=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)

        if [ "$UPPM_PKG_OS_ARCH" != '-' ] && [ "$UPPM_PKG_OS_ARCH" != "$NATIVE_OS_ARCH" ] ; then
            continue
        fi

        UPPM_PKG_OS_LIBC=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)

        if [ "$UPPM_PKG_OS_LIBC" != '-' ] && [ "$UPPM_PKG_OS_LIBC" != "$NATIVE_OS_LIBC" ] ; then
            continue
        fi

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)

        if [ "$UPPM_PKG_NAME" != "$1" ] ; then
            continue
        fi

        UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f5)

        if [ $# -ge 3 ] ; then
            if version_match "$UPPM_PKG_VERS" "$2" "$3" ; then
                break
            else
                continue
            fi
        fi

        break
    done

    if [ -z "$UPPM_PKG_LINE" ] ; then
        warn "no available prebuild package: $@"
        return 1
    fi

    unset UPPM_PKG_OS_KIND
    unset UPPM_PKG_OS_ARCH
    unset UPPM_PKG_OS_LIBC

    unset UPPM_PKG_NAME
    unset UPPM_PKG_VERS
    unset UPPM_PKG_SHA_
    unset UPPM_PKG_URL_

    UPPM_PKG_OS_KIND=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)
    UPPM_PKG_OS_ARCH=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)
    UPPM_PKG_OS_LIBC=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)

    UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)
    UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f5)
    UPPM_PKG_SHA_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f6)
    UPPM_PKG_URL_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f7)

    UPPM_PKG_FILETYPE=$(__uppm_get_filetype_from_url "$UPPM_PKG_URL_")

    UPPM_PKG_FILENAME="$UPPM_PKG_NAME-$UPPM_PKG_VERS"

    [ "$UPPM_PKG_OS_KIND" != '-' ]  && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME-$UPPM_PKG_OS_KIND"
    [ "$UPPM_PKG_OS_ARCH" != '-' ]  && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME-$UPPM_PKG_OS_ARCH"
    [ "$UPPM_PKG_OS_LIBC" != '-' ]  && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME-$UPPM_PKG_OS_LIBC"

    [ -n "$UPPM_PKG_FILETYPE" ]     && UPPM_PKG_FILENAME="$UPPM_PKG_FILENAME.$UPPM_PKG_FILETYPE"

    UPPM_PKG_FILEPATH="$HOME/.uppm/downloads/$UPPM_PKG_FILENAME"

    fetch "$UPPM_PKG_URL_" --sha256="$UPPM_PKG_SHA_" --output-path="$UPPM_PKG_FILEPATH"

    case $UPPM_PKG_FILETYPE in
        zip)
            handle_dependency required exe unzip
            ;;
        tar.xz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
        tar.gz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        tar.lz)
            handle_dependency required exe tar
            handle_dependency required exe lzip
            ;;
        tar.bz2)
            handle_dependency required exe tar
            handle_dependency required exe bzip2
            ;;
        tgz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        txz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
    esac

    if [ -z "$UPPM_PKG_INSTALLD_PREFIX" ] ; then
        UPPM_PKG_INSTALLD_PREFIX="$HOME/.uppm/install.d"
    fi

    UPPM_PKG_INSTALLD="$UPPM_PKG_INSTALLD_PREFIX/$UPPM_PKG_NAME"

    UPPM_PKG_INSTALLED_METADATA_FILEPATH="$UPPM_PKG_INSTALLD/installed-metadata"

    if [ -f "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" ] ; then
        if [ $# -ge 3 ] ; then
            if version_match "$(. "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" && printf '%s\n' "$INSTALLED_PACKAGE_VERSION")" "$2" "$3" ; then
                success "$UPPM_PKG_FILEPATH already have been unpacked to $UPPM_PKG_INSTALLD."
            else
                run rm -rf "$UPPM_PKG_INSTALLD"
            fi
        elif [ $# -ge 1 ] ; then
            success "$UPPM_PKG_FILEPATH already have been unpacked to $UPPM_PKG_INSTALLD."
        fi
    fi

    if [ ! -f "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" ] ; then
        if [ ! -d "$UPPM_PKG_INSTALLD" ] ; then
            install -o $(whoami) -d "$UPPM_PKG_INSTALLD" 2>/dev/null || sudo install -o $(whoami) -d "$UPPM_PKG_INSTALLD"
        fi
        case $UPPM_PKG_FILETYPE in
            zip)
                run unzip  "$UPPM_PKG_FILEPATH" -d "$UPPM_PKG_INSTALLD"
                ;;
            tar.xz|tar.gz|tar.lz|tar.bz2|tgz|txz|tlz)
                run tar xf "$UPPM_PKG_FILEPATH" -C "$UPPM_PKG_INSTALLD" --strip-components 1
                ;;
        esac

        cat > "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" <<EOF
INSTALLED_TIMESTAMP_UNIX='$(date +%s)'
INSTALLED_PACKAGE_NAME='$UPPM_PKG_NAME'
INSTALLED_PACKAGE_VERSION='$UPPM_PKG_VERS'
INSTALLED_PKG_URL_='$UPPM_PKG_URL_'
INSTALLED_PKG_SHA_='$UPPM_PKG_SHA_'
EOF
    fi

    if [ -d "$UPPM_PKG_INSTALLD/bin" ] ; then
        bppend_to_PATH "$UPPM_PKG_INSTALLD/bin"
    fi

    bppend_to_PATH "$UPPM_PKG_INSTALLD"

    case $UPPM_PKG_NAME in
        autoconf)
            for xx in $(grep '/root/.zpkg/install.d/autoconf' -rl "$UPPM_PKG_INSTALLD")
            do
                sed_in_place "s|/root/.zpkg/install.d/autoconf|$UPPM_PKG_INSTALLD|" "$xx"
            done
            ;;
        jdk)
            cat > "$UPPM_PKG_INSTALLD/env" <<EOF
bppend_to_PATH() {
    case ":\${PATH}:" in
        *:"\$@":*) ;;
        *) export PATH="\$@:\$PATH" ;;
    esac
}

JAVA_HOME="$UPPM_PKG_INSTALLD"

bppend_to_PATH "$UPPM_PKG_INSTALLD/bin"
EOF
            . "$UPPM_PKG_INSTALLD/env"

    esac
}

__uppm_help() {
    printf '%b\n' "
uppm (universal prebuild package manager)

uppm <ACTION> <ARGUMENT>...

uppm -h
uppm --help

uppm -V
uppm --version

uppm ls-available
uppm ls-installed

uppm is-available <PACKAGE-NAME> [eq|ne|lt|ge|lt|gt <VERSION>]
uppm is-installed <PACKAGE-NAME> [eq|ne|lt|ge|lt|gt <VERSION>]

uppm search       <keyword>

uppm info         [PACKAGE-NAME]

uppm fetch        <PACKAGE-NAME> [OUTPUT-DIR]

uppm install      <PACKAGE-NAME> [eq|ne|lt|ge|lt|gt <VERSION>]"
}

uppm() {
    set -e

    case $1 in
        -h|--help|'')
            __uppm_help
            ;;
        -V|--version)
            printf "0.0.1"
            ;;
        ls-available)
            shift
            __uppm_list_the_available_packages
            ;;
        ls-installed)
            shift
            __uppm_list_the_installed_packages
            ;;
        is-available)
            shift
            __uppm_is_the_given_package_available $@
            ;;
        is-installed)
            shift
            __uppm_is_the_given_package_installed $@
            ;;
        install)
            shift
            __uppm_install_the_given_package $@
            ;;
        *)  error "uppm unrecognized ACTION: $1"
            __uppm_help
            exit 1
    esac
}

__uppm_get_package_name_by_command_name() {
    [ -z "$1" ] && {
        error "__uppm_get_package_name_by_command_name <CMD>, <CMD> must not be empty."
        return 1
    }

    case $1 in
        python|python3) printf '%s\n' 'python3' ;;
        autoconf)       printf '%s\n' 'autoconf';;
        autoreconf)     printf '%s\n' 'autoconf';;
        go)             printf '%s\n' 'golang'  ;;
        git)            printf '%s\n' 'git'     ;;
        file)           printf '%s\n' 'file'    ;;
        java)           printf '%s\n' 'jdk'     ;;
        cmake)          printf '%s\n' 'cmake'   ;;
        ninja)          printf '%s\n' 'ninja'   ;;
        *)              printf '%s\n' "$1"
    esac
}

# __install_command_via_uppm <CMD> [eq|ne|le|ge|lt|gt <VERSION>]
__install_command_via_uppm() {
    [ -z "$1" ] && {
        error "__install_command_via_uppm <CMD>, <CMD> must not be empty."
        return 1
    }

    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    UPPM_PKG_NAME=$(__uppm_get_package_name_by_command_name "$1")
    if  uppm is-available "$UPPM_PKG_NAME" $2 $3 ; then
        note "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}uppm${COLOR_OFF}"
        uppm install      "$UPPM_PKG_NAME"
    else
        return 1
    fi
}

# __install_command_via_pmw <CMD> [eq|ne|le|ge|lt|gt <VERSION>]
__install_command_via_pmw() {
    [ -z "$1" ] && {
        error "__install_command_via_pmw <CMD> [eq|ne|le|ge|lt|gt <VERSION>] , <CMD> must not be empty."
        return 1
    }

    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    AVAILABLE_PACKAGE_MANAGER_LIST=$(__pmw_get_available_pm_list | tr '\n' ' ')
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        warn "no package manager found."
        return 1
    else
        note "Found $(list_length $AVAILABLE_PACKAGE_MANAGER_LIST) package manager : ${COLOR_GREEN}$AVAILABLE_PACKAGE_MANAGER_LIST${COLOR_OFF}"
    fi

    for pm in $AVAILABLE_PACKAGE_MANAGER_LIST
    do
        unset PMW_PM_NAME_UNDERSCORE
        unset PMW_REPO_PKG_ITEM
        unset PMW_REPO_NAME
        unset PMW_PKG__NAME

        PMW_PM_NAME_UNDERSCORE="$(printf '%s\n' "$pm" | tr - _)"
        PMW_REPO_PKG_ITEM="$(eval __pmw_get_available_package_name_by_command_name_$PMW_PM_NAME_UNDERSCORE $1)"

        # if pacmakge name is empty, I assume that command name is equal to package name.
        if [ -z "$PMW_REPO_PKG_ITEM" ] ; then
            PMW_REPO_NAME=default
            PMW_PKG__NAME="$1"
        else
            case $PMW_REPO_PKG_ITEM in
                *:*)
                    PMW_REPO_NAME=$(printf '%s\n' "$PMW_REPO_PKG_ITEM" | cut -d: -f1)
                    PMW_PKG__NAME=$(printf '%s\n' "$PMW_REPO_PKG_ITEM" | cut -d: -f2)
                    ;;
                *)  PMW_REPO_NAME=default
                    PMW_PKG__NAME="$PMW_REPO_PKG_ITEM"
            esac
        fi
        __pmw_install_the_given_package "$pm" "$PMW_REPO_NAME" "$PMW_PKG__NAME" $2 $3 && return 0
    done
    return 1
}

__install_command_via_run_install_script() {
    case $1 in
        java|javac|jar)
            install_jdk_if_needed
            ;;
        adb|aapt|aapt2|sdkmanager|zipalign)
            install_android_sdk_if_needed
            ;;
        gclient)
            handle_dependency required exe git || return 1

            # https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html

            if [ !          -d "$MY_HOME_DIR/native" ] ; then
                run install -d "$MY_HOME_DIR/native" || return 1
            fi

            if [ -d "$MY_HOME_DIR/native/depot_tools" ] ; then
                if [ -d "$MY_HOME_DIR/native/depot_tools/.git" ] && git -C "$MY_HOME_DIR/native/depot_tools" rev-parse 2> /dev/null ; then
                    # do nothing. depot_tools will be automatically updated when you running 'yes | gclient sync' command
                    :
                else
                    run rm -rf "$MY_HOME_DIR/native/depot_tools" || return 1
                    run git -C "$MY_HOME_DIR/native/depot_tools" clone https://gitlab.com/webrtc-mirror/depot_tools.git || return 1
                fi
            else
                run git -C "$MY_HOME_DIR/native" clone https://gitlab.com/webrtc-mirror/depot_tools.git || return 1
            fi

            export PATH="$MY_HOME_DIR/native/depot_tools:$PATH"
            ;;
        xmake)
            handle_dependency required exe bash || return 1

            # https://xmake.io/#/guide/installation
            note "${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via running shell script.${COLOR_OFF}"

            if [ -f    "$MY_HOME_DIR/tmp.d/get-xmake.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/get-xmake.sh" || return 1
            fi

            fetch 'https://xmake.io/shget.text' --output-path="$MY_HOME_DIR/tmp.d/get-xmake.sh" || return 1

            run bash "$MY_HOME_DIR/tmp.d/get-xmake.sh"
            ;;
        rustup)
            handle_dependency required exe bash:zsh:dash:ash || return 1

            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via running shell script.${COLOR_OFF}"

            if [ -f    "$MY_HOME_DIR/tmp.d/rustup-init.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/rustup-init.sh" || return 1
            fi

            fetch 'https://sh.rustup.rs' --output-path="$MY_HOME_DIR/tmp.d/rustup-init.sh" || return 1

            run $(command -v bash || command -v zsh || command -v dash || command -v ash || command -v sh) "$MY_HOME_DIR/tmp.d/rustup-init.sh" -y || return 1

            export CARGO_HOME=$HOME/.cargo
            export PATH="$CARGO_HOME/bin:$PATH"
            ;;
        nvm)
            # https://github.com/nvm-sh/nvm
            note "${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via running bash shell script.${COLOR_OFF}"

            handle_dependency required exe bash:zsh || return 1

            if [ -f    "$MY_HOME_DIR/tmp.d/install-nvm.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/install-nvm.sh" || return 1
            fi

	        fetch "$(github_user_content_base_url)/nvm-sh/nvm/master/install-nvm.sh" || return 1

            run $(command -v bash || command -v zsh || printf '%s\n' bash) "$MY_HOME_DIR/tmp.d/install-nvm.sh" || return 1

	        export NVM_DIR="${HOME}/.nvm"
	        . "${HOME}/.nvm/nvm.sh"
            ;;
        *)  return 1
    esac
}

__install_command_via_pip() {
    if [ -z "$(__pmw_get_available_package_name_by_command_name_pip3 "$1")" ] ; then
        return 1
    fi

    handle_dependency required exe pip3:pip || return 1

    (
        unset __PIP_COMMAND__
        __PIP_COMMAND__="$(command -v pip3.8)"

        if [ -n "$__PIP_COMMAND__" ] && [ -d '/usr/local/bin' ] ; then
            $sudo ln -sf "$__PIP_COMMAND__" /usr/local/bin/pip3
        fi
    )

    if   command_exists_in_filesystem pip3 ; then
        __pmw_install_the_given_package pip3 default "$(__pmw_get_available_package_name_by_command_name_pip3 "$1")"
    elif command_exists_in_filesystem pip ; then
        __pmw_install_the_given_package pip  default "$(__pmw_get_available_package_name_by_command_name_pip "$1")"
    else
        return 1
    fi
}

# __install_command <CMD> [OP VERSION]
# __install_command python3 ge 3.5
# __install_command make
__install_command() {
    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    if __install_command_via_run_install_script $@ ; then
        return 0
    fi

    if __install_command_via_pip $@ ; then
        return 0
    fi

    if __install_command_via_pmw $@ ; then
        return 0
    fi

    if __install_command_via_uppm $@ ; then
        return 0
    fi

    warn "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but I found no way to install it.${COLOR_OFF}\n"
    return 1
}

# usage:
# handle_depnedency <required|optional> <exe|pym|plm> [eq|ne|ge|lt|gt|lt <VERSION>]
#
# examples:
# handle_dependency required exe python      ge 3.5
# handle_dependency required pym libxml2     ge 2.19
# handle_dependency required plm XML::Parser ge 2.45
#
# handle_dependency optional exe python      ge 3.5
# handle_dependency optional pym libxml2     ge 2.19
# handle_dependency optional plm XML::Parser ge 2.45
handle_dependency() {
    [ "$1" = 'required' ] || return 0

    shift

    case $1 in
        exe)
            shift
            case $1 in
                *:*)
                    for CMD in $(printf '%s\n' "$1" | tr ':' ' ')
                    do
                        if command_exists_in_filesystem_and_version_matched "$CMD" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$CMD"
                            return 0
                        fi
                    done

                    for CMD in $(printf '%s\n' "$1" | tr ':' ' ')
                    do
                        if __install_command "$CMD" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$CMD"
                            return 0
                        fi
                    done

                    return 1
                    ;;
                *)  __install_command $@
            esac
            ;;
        pym)
            shift
            python_module install $@
            ;;
        plm)
            shift
            perl_module   install $@
            ;;
        *)  error "handle_dependency() unrecognized argument:$1" ; return 1
    esac
}

__handle_required_dependencies() {
    step "handle required dependencies"

    for dependency in $REQUIRED_DEPENDENCY_LIST
    do
        handle_dependency $(__decode_dependency "$dependency")
    done
}

# }}}
##############################################################################
# {{{ __printf_dependencies

# examples:
# __printf_dependency required exe python      ge 3.5
# __printf_dependency required pym libxml2     ge 2.19
# __printf_dependency required plm XML::Parser ge 2.45
#
# __printf_dependency optional exe python      ge 3.5
# __printf_dependency optional plm libxml2     ge 2.19
# __printf_dependency optional plm XML::Parser ge 2.45
__printf_dependency() {
    printf "%-10s %-15s %-2s %-10s %-10s %s\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

# examples:
# printf_dependency required exe python      ge 3.5
# printf_dependency required pym libxml2     ge 2.19
# printf_dependency required plm XML::Parser ge 2.45
#
# printf_dependency optional exe python      ge 3.5
# printf_dependency optional pym libxml2     ge 2.19
# printf_dependency optional plm XML::Parser ge 2.45
printf_dependency() {
    case $2 in
        exe)
            case $3 in
                *:*)
                    if [ "$1" = 'required' ] ; then
                        REQUIRED_ITEM="$(map_get MAP_REQUIRED_DEPENDENCIES "$3")"
                        __printf_dependency "$2" "$REQUIRED_ITEM" "$4" "$5" "$(version_of_command $REQUIRED_ITEM)" "$(command -v $REQUIRED_ITEM)"
                    else
                        for item in $(printf '%s\n' "$3" | tr ':' ' ')
                        do
                            __printf_dependency "$2" "$item" "$4" "$5" "$(version_of_command $item)" "$(command -v $item)"
                        done
                    fi
                    ;;
                *)  __printf_dependency "$2" "$3" "$4" "$5" "$(version_of_command $3)" "$(command -v $3)"
            esac
            ;;
        pym)
            __printf_dependency "$2" "$3" "$4" "$5" "$(python_module get-version "$item")" "$(python_module get-location "$item")"
            ;;
        plm)
            __printf_dependency "$2" "$3" "$4" "$5" "$(perl_module get-version "$item")" "$(perl_module get-location "$item")"
            ;;
        *)  error "printf_dependency() unrecognized argument: $2" ; return 1
    esac
}

__printf_required_dependencies() {
    step "printf required dependencies"
    if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
        note "no required dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $REQUIRED_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

__printf_optional_dependencies() {
    step "printf optional dependencies"
    if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
        note "no optional dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $OPTIONAL_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

# }}}
##############################################################################
# {{{ python_module

# examples:
# python_module is  installed libxml2
# python_module get version   libxml2
# python_module get location  libxml2
# python_module install       libxml2
python_module() {
    case $1 in
        is)
            [ $# -eq 3 ] || {
                error "[python_module is] command accept 2 arguments."
                return 1
            }

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python || return 1
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip || return 1

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || printf '%s\n' python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || printf '%s\n' pip)

            case $2 in
                installed)  "$__PYTHON_COMMAND__" -c "import $3" 2> /dev/null ;;
                *) error "python_module is $2: not support." ; return 1
            esac
            ;;
        get)
            [ $# -eq 3 ] || {
                error "[python_module get] command accept 2 arguments."
                return 1
            }

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python || return 1
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip || return 1

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || printf '%s\n' python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || printf '%s\n' pip)

            case $2 in
                version)  "$__PIP_COMMAND__" show "$3" 2> /dev/null | sed -n '/Version:/p'  | cut -d ' ' -f2 ;;
                location) "$__PIP_COMMAND__" show "$3" 2> /dev/null | sed -n '/Location:/p' | cut -d ' ' -f2 ;;
                *) error "python_module get $2: not support." ; return 1
            esac
            ;;
        install)
            [ -z "$2" ] && {
                error "please specify a python module name."
                return 1
            }

            if ! python_module is installed "$2" ; then
                note "${COLOR_GREEN}$2${COLOR_OFF} ${COLOR_YELLOW}python module is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}$__PIP_COMMAND__${COLOR_OFF}"
                run "$__PIP_COMMAND__" install -U pip
                run "$__PIP_COMMAND__" install -U "$2"
            fi
            ;;
        *)  error "python_module $1: not support." ; return 1
    esac
}

# }}}
##############################################################################
# {{{ perl_module

# examples:
# perl_module is-installed  XML::Parser
# perl_module install       XML::Parser
# perl_module get-version   XML::Parser
# perl_module get-location  XML::Parser
perl_module() {
    case $1 in
        get-version)
            shift
            cpan -l 2>/dev/null | sed -n "/$1/p" | head -n 1 | cut -f2
            ;;
        get-location)
            shift
            __PERL_MODULE_NAME_TO_PATH=$(printf "%s.pm\n" "$1" | sed 's|::|/|g')
            for item in $(perl -e 'print "@INC"')
            do
                if [ -e           "$item/$__PERL_MODULE_NAME_TO_PATH" ] ; then
                    printf '%s\n' "$item/$__PERL_MODULE_NAME_TO_PATH"
                    return 0
                else
                    continue
                fi
                return 1
            done
            ;;
        is-installed)
            shift
            handle_dependency required exe perl || return 1
            perl -M"$1" -le 'print "installed"' > /dev/null 2>&1
            ;;
        install)
            shift
            perl_module is-installed "$1" && return 0

            if command_exists_in_filesystem cpan  ; then
                note "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}perl module is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}cpan${COLOR_OFF}"
                run cpan -i "$1"
            elif command_exists_in_filesystem cpanm ; then
                note "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}perl module is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}cpanm${COLOR_OFF}"
                run cpanm "$1"
            else
                handle_dependency required exe cpan:cpanm || return 1
                perl_module install $@
            fi
            ;;
        *)  error "perl_module $1: not support." ; return 1
    esac
}

# }}}
##############################################################################
# {{{ encode/decode dependency

__encode_dependency() {
    if [ $# -eq 0 ] ; then
        tr ' ' '|'
    else
        printf "%s" "$*" | tr ' ' '|'
    fi
}

__decode_dependency() {
    if [ $# -eq 0 ] ; then
        tr '|' ' '
    else
        printf "%s" "$*" | tr '|' ' '
    fi
}

# }}}
##############################################################################
# {{{ regist dependency

# regist dependency required|optional exe|lib|dev|py|pm|pip|npm|gem|pub|cargo|go NAME
#
# required this is a required dependency
# optional this is a optional dependency
#
# exe  this dependency is a command
# py   this dependency is a python  module
# py2  this dependency is a python2 module
# py3  this dependency is a python3 module
# pm   this dependency is a perl module
#
# gt VERSION
# ge VERSION
# lt VERSION
# le VERSION
# eq VERSION
# ne VERSION
#
# examples:
# regist_dependency required exe pkg-config ge 0.18
# regist_dependency required exe python     ge 3.5
# regist_dependency required py  libxml2    ge 2.19
#
# regist_dependency optional exe pkg-config ge 0.18
# regist_dependency optional exe python     ge 3.5
# regist_dependency optional py  libxml2    ge 2.19
regist_dependency() {
    case $1 in
        required)
            if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
                REQUIRED_DEPENDENCY_LIST="$(__encode_dependency "$*")"
            else
                REQUIRED_DEPENDENCY_LIST="$REQUIRED_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
            ;;
        optional)
            if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
                OPTIONAL_DEPENDENCY_LIST=$(__encode_dependency "$*")
            else
                OPTIONAL_DEPENDENCY_LIST="$OPTIONAL_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
    esac
}

# }}}
##############################################################################
# {{{ perform_*

perform_config() {
    [ "$DEBUG" = 'true' ] && step 'perform cmakew config'

    unset GENERATOR_SET
    unset BUILD_DIR_SET

    unset CMAKE_EXPORT_COMPILE_COMMANDS
    unset CMAKE_VERBOSE_MAKEFILE
    unset CMAKE_COLOR_MAKEFILE

    unset BUILD_DIR
    unset BUILD_SYS
    unset GENERATOR

    unset CMAKE_FLAGS
    
    for item in $@
    do
        case $item in
            -DCMAKE_EXPORT_COMPILE_COMMANDS=*)
              CMAKE_EXPORT_COMPILE_COMMANDS=$(getvalue "$item")
              ;;
            -DCMAKE_VERBOSE_MAKEFILE=*)
              CMAKE_VERBOSE_MAKEFILE=$(getvalue "$item")
              ;;
            -DCMAKE_COLOR_MAKEFILE=*)
              CMAKE_COLOR_MAKEFILE=$(getvalue "$item")
              ;;
            -B) BUILD_DIR_SET=true ;;
            -G) GENERATOR_SET=true ;;
            *)  if [ "$BUILD_DIR_SET" = 'true' ] ; then
                    BUILD_DIR="$item"
                    unset BUILD_DIR_SET
                fi
                if [ "$GENERATOR_SET" = 'true' ] ; then
                    GENERATOR="$item"
                    unset GENERATOR_SET
                fi
        esac
    done

    if [ -z "$CMAKE_EXPORT_COMPILE_COMMANDS" ] ; then
        CMAKE_EXPORT_COMPILE_COMMANDS=ON
    fi

    if [ -z "$CMAKE_VERBOSE_MAKEFILE" ] ; then
        CMAKE_VERBOSE_MAKEFILE=ON
    fi

    if [ -z "$CMAKE_COLOR_MAKEFILE" ] ; then
        CMAKE_COLOR_MAKEFILE=ON
    fi

    CMAKE_FLAGS="
        -DCMAKE_EXPORT_COMPILE_COMMANDS=$CMAKE_EXPORT_COMPILE_COMMANDS
        -DCMAKE_VERBOSE_MAKEFILE=$CMAKE_VERBOSE_MAKEFILE
        -DCMAKE_COLOR_MAKEFILE=$CMAKE_COLOR_MAKEFILE"

    if [ -z "$GENERATOR" ] ; then
        GENERATOR='Unix Makefiles'
        if [ "$NATIVE_OS_TYPE" = 'windows' ] ; then
            CMAKE_FLAGS="$CMAKE_FLAGS -G 'Unix Makefiles'"
        fi
    fi

    if [ "$GENERATOR" = 'Unix Makefiles' ] ; then
        BUILD_SYS=make
        handle_dependency required exe make
    elif [ "$GENERATOR" = 'Ninja' ] ; then
        BUILD_SYS=ninja
        handle_dependency required exe ninja
    fi

    if [ -z "$BUILD_DIR" ] ; then
        BUILD_DIR="$PROJECT_DIR/build.d"
    fi

    if command_exists_in_filesystem_and_version_matched cmake ge 3.13.0 ; then
        CMAKE_FLAGS="$CMAKE_FLAGS -Wno-dev -S . -B build.d $@"
    elif command_exists_in_filesystem_and_version_matched cmake lt 3.13.0 ; then
        # https://stackoverflow.com/questions/11143062/getting-cmake-to-build-out-of-source-without-wrapping-scripts
        CMAKE_FLAGS="$CMAKE_FLAGS -Wno-dev -H. -Bbuild.d $@"
    else
        die "cmake not found."
    fi

    if run cmake $CMAKE_FLAGS ; then
        printf "%s\n" "BUILD_DIR='$BUILD_DIR'"  > "$PROJECT_DIR/.cmakew"
        printf "%s\n" "BUILD_SYS='$BUILD_SYS'" >> "$PROJECT_DIR/.cmakew"
        printf "%s\n" "BUILD_YES=0"            >> "$PROJECT_DIR/.cmakew"
    else
        rm -f "$PROJECT_DIR/.cmakew"
        return 1
    fi
}

##################################################################

perform_build() {
    [ "$DEBUG" = 'true' ] && step 'perform cmakew build'
    if [ -f .cmakew ] ; then
        . ./.cmakew || return 1
        if run cmake --build "$BUILD_DIR" ; then
            printf "%s\n" "BUILD_DIR='$BUILD_DIR'"  > "$PROJECT_DIR/.cmakew"
            printf "%s\n" "BUILD_SYS='$BUILD_SYS'" >> "$PROJECT_DIR/.cmakew"
            printf "%s\n" "BUILD_YES=1"            >> "$PROJECT_DIR/.cmakew"
        else
            return 1
        fi
    else
        die "haven't configed. please run ./cmakew config first."
    fi
}

##################################################################

perform_install() {
    if [ -f .cmakew ] ; then
        . ./.cmakew || return 1
        if [ "$BUILD_YES" != 1 ] ; then
            main build || return 1
        fi
        [ "$DEBUG" = 'true' ] && step 'perform cmakew install'
        # https://stackoverflow.com/questions/34040522/is-there-a-cmake-install-switch/34040747
        if command_exists_in_filesystem_and_version_matched cmake ge 3.15.0 ; then
            run cmake --install "$BUILD_DIR"
        else
            run "$BUILD_SYS" -C "$BUILD_DIR" install
        fi
    else
        [ "$DEBUG" = 'true' ] && step 'perform cmakew install'
        die "haven't configed. please run ./cmakew config first."
    fi
}

##################################################################

perform_pack() {
    [ "$DEBUG" = 'true' ] && step 'perform cmakew pack'
    if [ -f .cmakew ] ; then
        . ./.cmakew || return 1
        for item in CPackConfig.cmake CPackSourceConfig.cmake
        do
            if [ -f "$BUILD_DIR/$item" ] ; then
                run cpack --config "$BUILD_DIR/$item" || return 1
            fi
        done
    else
        die "haven't configed. please run ./cmakew config first."
    fi
}

##################################################################

perform_test() {
    [ "$DEBUG" = 'true' ] && step 'perform cmakew test'

    unset CTEST_FLAGS
    unset CTEST_DIR
    unset BUILD_DIR
    unset OUTPUT_ON_FAILURE

    for item in $@
    do
        case $item in
            --test-dir)
                CTEST_DIR=$(getvalue "$item")
                ;;
            --output-on-failure)
                OUTPUT_ON_FAILURE='true'
        esac
    done

    if [ -f .cmakew ] ; then
        . ./.cmakew || return 1

        if [ "$BUILD_YES" != 1 ] ; then
            die "haven't built. please run ./cmakew build."
        fi

        if [ "$OUTPUT_ON_FAILURE" = 'true' ] ; then
            unset OUTPUT_ON_FAILURE
        else
            OUTPUT_ON_FAILURE='--output-on-failure'
        fi

        if [ -z "$CTEST_DIR" ] ; then
            CTEST_FLAGS="--test-dir $BUILD_DIR $@ $OUTPUT_ON_FAILURE"
        else
            CTEST_FLAGS="$@ $OUTPUT_ON_FAILURE"
        fi

        run ctest $CTEST_FLAGS || return 1
    else
        die "haven't configed. please run ./cmakew config first."
    fi
}

perform_cppcheck() {
    [ "$DEBUG" = 'true' ] && step 'perform cmakew cppcheck'

    if [ -f .cmakew ] ; then
        . ./.cmakew || return 1
        if [ -f "$BUILD_DIR/compile_commands.json" ] ; then
            run cppcheck --project="$BUILD_DIR/compile_commands.json"
        else
            die "you should set -DCMAKE_EXPORT_COMPILE_COMMANDS=ON when run ./cmakew config"
        fi
    else
        die "haven't configed. please run ./cmakew config first."
    fi
}

##################################################################

perform_clean() {
    [ "$DEBUG" = 'true' ] && step 'perform cmakew clean'
    if [ -f .cmakew ] ; then
        . ./.cmakew || return 1
        run rm -rf "'$BUILD_DIR'"
        run rm -rf .cmakew
    fi
}

##################################################################

main() {
    set -e

    MY_VERSION=0.1.0

    case $1 in
        ''|-h|--help)
            echo "${COLOR_GREEN}cmakew ($MY_VERSION) is a cmake wrapper which is desinged to help you using cmake easily.${COLOR_OFF}"
            cat <<EOF

Usage:
./cmakew -h | --help             -- show help    of this command.

./cmakew -V | --version          -- show version of this command.

./cmakew upgrade [-x | --china]  -- upgrade this software.

./cmakew integrate zsh [-x | --china]           -- download a zsh-completions script to a approprivate location.

./cmakew config  [ -x | -d | -rc-file=FILE ] [option]...   -- generate config cache

./cmakew build   [ -x | -d | -rc-file=FILE ] [option]...   -- build configed

./cmakew install [ -x | -d | -rc-file=FILE ] [option]...   -- install prebuild to destination

./cmakew pack    [ -x | -d | -rc-file=FILE ] [option]...   -- pack source and binary archive

./cmakew test    [ -x | -d | -rc-file=FILE ] [option]...   -- run tests

./cmakew cppcheck[ -x | -d | -rc-file=FILE ] [option]...   -- run cppcheck static analysis

./cmakew clean   [ -x | -d | -rc-file=FILE ]               -- remove build dir
EOF
            return 0
            ;;
        -V|--version)
            printf '%s\n' '1.0.0'
            return 0
            ;;
        upgrade)
            shift
            __upgrade_self 'https://raw.githubusercontent.com/leleliu008/cmakew/master/cmakew' $@
            return 0
            ;;
        integrate)
            shift
            case $1 in
                zsh)
                    shift
                    __integrate_zsh_completions 'https://raw.githubusercontent.com/leleliu008/cmakew/master/zsh-completion/_cmakew' $@
                    return 0
                    ;;
                *)  die "cmakew integrate $1: not support."
            esac
            ;;
         env)
            echo "${COLOR_GREEN}cmakew ($MY_VERSION) is a cmake wrapper which is desinged to help you using cmake easily.${COLOR_OFF}"
            echo
            run os
            echo
            run "id | tr ' ' '\n'"
            echo
            run env
            echo
            run export -p

            return 0
            ;;
    esac

    unset DEBUG

    unset STEP_NUM
    unset STEP_MESSAGE

    unset REQUIRED_DEPENDENCY_LIST
    unset OPTIONAL_DEPENDENCY_LIST

    unset PROJECT_DIR
    unset PROJECT_NAME
    unset PROJECT_VERSION

    unset NATIVE_OS_TYPE
    unset NATIVE_OS_NAME
    unset NATIVE_OS_VERS
    unset NATIVE_OS_SUBS
    unset NATIVE_OS_ARCH
    unset NATIVE_OS_LIBC

    unset CMAKE_VERSION_MREQUIRED

    unset PREBUILD_BINARY_INSTALL_PREFIX_DIR
    PREBUILD_BINARY_INSTALL_PREFIX_DIR='/opt'

    # pip install --user <PKG>
    export PATH=$HOME/.local/bin:$PATH

    unset RC_FILE

    ACTION="$1"

    shift

    unset ACTION_ARGS

    while [ -n "$1" ]
    do
        case $1 in
            -x) set -x ;;
            -d) DEBUG=true ;;
            --rc-file=*)
                RC_FILE=$(getvalue "$1")
                if [ -z "$RC_FILE" ] ; then
                    die "--rc-file=FILE FILE must not empty."
                else
                    [ -e "$RC_FILE" ] || die "--rc-file=FILE, FILE[$RC_FILE] file is not exist."
                fi
                ;;
            *)  ACTION_ARGS="$ACTION_ARGS $1"
        esac
        shift
    done

    regist_dependency required exe gsed:sed
    regist_dependency required exe grep

    if [ -d "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
        for item in $(ls "$PREBUILD_BINARY_INSTALL_PREFIX_DIR")
        do
            if [ -d "$PREBUILD_BINARY_INSTALL_PREFIX_DIR/$item/bin" ] ; then
                export PATH="$PREBUILD_BINARY_INSTALL_PREFIX_DIR/$item/bin:$PATH"
            fi
        done
    fi

    if [ "$DEBUG" = 'true' ] ; then
        step "handle essential tools"
    fi
    for dependency in $REQUIRED_DEPENDENCY_LIST
    do
        handle_dependency $(__decode_dependency "$dependency") || return 1
    done

    [ -z "$RC_FILE" ] && RC_FILE='./cmakew.rc'

    if [ "$DEBUG" = 'true' ] ; then
        step "load $RC_FILE"
    fi
    if file_exists "$RC_FILE" ; then
        if . "$RC_FILE" ; then
            if [ "$DEBUG" = 'true' ] ; then
                success "$RC_FILE loaded successfully."
            fi
        else
            die "$RC_FILE load failed."
        fi
    else
        warn "$RC_FILE not exist. skipped."
    fi

    type "perform_$ACTION" | grep -q function || die "unrecognized action: $ACTION"

    NATIVE_OS_KIND=$(os kind)
    NATIVE_OS_TYPE=$(os type)
    NATIVE_OS_NAME=$(os name)
    NATIVE_OS_VERS=$(os vers)
    NATIVE_OS_SUBS=$(os subs)
    NATIVE_OS_ARCH=$(os arch)
    NATIVE_OS_LIBC=$(os libc)

    if [ "$NATIVE_OS_TYPE" != 'windows' ] && [ "$NATIVE_OS_SUBS" != termux ] ; then
        [ "$(whoami)" = root ] || sudo=sudo
    fi

    [ -f CMakeLists.txt ] || die "CMakeLists.txt is not exist."

    PROJECT_DIR=$(dirname "$CURRENT_SCRIPT_FILEPATH")

    # https://cmake.org/cmake/help/latest/command/project.html
    PROJECT_NAME=$(grep 'project(.*).*' CMakeLists.txt | sed 's/project(\(.*\)).*/\1/'| cut -d' ' -f1)
    PROJECT_VERSION=$(grep 'set(PACKAGE_VERSION .*).*' CMakeLists.txt | sed 's/set(PACKAGE_VERSION \(.*\)).*/\1/')
    
    CMAKE_VERSION_MREQUIRED=$(grep 'cmake_minimum_required(VERSION ' CMakeLists.txt | sed 's/cmake_minimum_required(VERSION[[:space:]]*\(.*\))/\1/')
    if [ -z "$CMAKE_VERSION_MREQUIRED" ] ; then
        CMAKE_VERSION_MREQUIRED=$(grep 'CMAKE_MINIMUM_REQUIRED(VERSION[[:space:]]\[.*\])[[:space:]]*$' CMakeLists.txt | sed 's/CMAKE_MINIMUM_REQUIRED(VERSION[[:space:]]*\(.*\))/\1/')
    fi
    if [ -z "$CMAKE_VERSION_MREQUIRED" ] ; then
        regist_dependency required exe cmake
    else
        regist_dependency required exe cmake ge "$CMAKE_VERSION_MREQUIRED"
    fi

    if  type "perform_${ACTION}_pre" | grep -q function ; then
        eval "perform_${ACTION}_pre $ACTION_ARGS"
    fi

    if [ "$DEBUG" = 'true' ] ; then
        step "show current machine os info"
        cat <<EOF
NATIVE_OS_TYPE  = $NATIVE_OS_TYPE
NATIVE_OS_NAME  = $NATIVE_OS_NAME
NATIVE_OS_VERS  = $NATIVE_OS_VERS
NATIVE_OS_SUBS  = $NATIVE_OS_SUBS
NATIVE_OS_ARCH  = $NATIVE_OS_ARCH
NATIVE_OS_LIBC  = $NATIVE_OS_LIBC
EOF

        step "show current machine os effective user info"
        id | tr ' ' '\n' | head -n 2

        step "show current project info"
        cat <<EOF
PROJECT_DIR     = $PROJECT_DIR
PROJECT_NAME    = $PROJECT_NAME
PROJECT_VERSION = $PROJECT_VERSION
EOF

        step "show PATH"
        for item in $(echo "$PATH" | tr ' ' '|' | tr ':' ' ')
        do
            printf '%s\n' "$item" | tr '|' ' '
        done
    fi

    __handle_required_dependencies

    if [ "$DEBUG" = 'true' ] ; then
        __printf_required_dependencies
        __printf_optional_dependencies
    fi

    eval "perform_$ACTION $ACTION_ARGS"

    if  type "perform_${ACTION}_post" | grep -q function ; then
        eval "perform_${ACTION}_post $ACTION_ARGS"
    fi
}

main $@
